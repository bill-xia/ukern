简单计划一下。
首先要选好工具链，配好开发环境。
搞好这一套之后先进入64位模式。
然后设计一下内存空间的分布，开启页表。
然后实现printf和字符驱动，打印调试信息。
这一套搞好以后，开始设计虚拟内存的数据结构和接口，实现。
然后设计用户内存空间的分布，设计用户进程的数据结构，准备进入用户空间。
然后配置简单的中断处理，让用户能够访问系统调用。
然后开启时钟，进行用户任务的抢占式调度。
现在，将之前的所有东西理清楚，做得完整一些。
然后开启多核，开始实现内核锁。
然后实现IPC。
然后实现文件系统和shell。

2022.4.27
项目开工了。22:30前写了第一版README，开始配环境。

2022.5.1
现在进了64位模式，配好了qemu和gdb调试。物理机和qemu都能跑，但vmware fusion不能跑，神秘。
现在急需支持更大的可执行文件，然而BIOS只会帮我们搬运第一个sector。6.828的解决方案是把elf文件直接存在第2个sector上，我觉得这不太合理。于是决定做一个文件系统。准备做FAT32，最大的缺点是不支持Unix权限管理。目前阶段只要做出来第一个扇区的格式和读取文件两个功能就够了。应该是可以用C写这个逻辑的，不知道一个扇区装不装得下。
所以下一步工作：
1. 实现第一个扇区的格式
2. 用C语言实现读取逻辑，然后将汇编和C链成一个文件

2022.7.30
现在放弃了在第一个扇区内实现文件系统的想法，选择将内核代码直接append在MBR后面，然后硬编码内核代码的位置，来加载内核。即便如此，MBR的空间也所剩无几了。
现在先在32位模式下读取并进入了内核，然后在进入内核的C代码前进入了64位模式，并配置了简单的页表和简单的GDT。
下一步的工作（几项并列）：
1. 搞一套C语言调用汇编语言的库，用来加载各种非通用寄存器
2. 细粒度配置的GDT, LDT, IDT
3. printk函数
4. 设计内存空间，细粒度配置页表

https://stackoverflow.com/questions/6917503/is-it-possible-to-use-32-bits-registers-instructions-in-real-mode